<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="img/s-solid.svg">
    <title>Spondan Bandyopadhyay</title>
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/project-style.css">
</head>
<body>

    <!-- Header Section -->
    <header>
        <div class="logo">
            <a href="index.html">
                <b>
                    <h3>Spondan Bandyopadhyay</h3>
                </b>
            </a>
        </div>
        <div class="navbar">
            <h3>
                <ul>
                    <li>
                        <a href="index.html">
                            <p class="animated-underline">Home</p>
                        </a>
                    </li>
                    <li>
                        <a href="projects.html">
                            <p class="animated-underline" id="current-tab">Projects</p>
                        </a>
                    </li>
                    <li>
                        <a href="experience.html">
                            <p class="animated-underline">Experience</p>
                        </a>
                    </li>
                    <li>
                        <a href="about.html">
                            <p class="animated-underline">About</p>
                        </a>
                    </li>
                </ul>
            </h3>
        </div>
        <div class="social-links">
            <a href="https://github.com/SpondanB" target="_blank" alt="GitHub"><img src="https://cdn0.iconfinder.com/data/icons/shift-logotypes/32/Github-1024.png" alt="GitHub"><!--GitHub🐈‍⬛--></a>
            <a href="https://www.linkedin.com/in/spondan-bandyopadhyay-562b15291/" target="_blank" alt="LinkedIn"><img src="https://cdn0.iconfinder.com/data/icons/social-hatched-block-set/512/linkedIn-512.png" alt="LinkedIn"><!--LinkedIn🪪--></a>
            <a href="mailto:spondan2003@gmail.com" alt="Email"><img src="https://cdn0.iconfinder.com/data/icons/iconico-3/128/58.png" alt="Email"><!--Email📧--></a>
        </div>
    </header>

    <!-- Main Content -->
    <main>
        <div class="projects">
            <div class="p-heading">
                <div><h1>Projects</h1></div>
                <h2>Following are few of the projects that I developed.</h2>
                <h3>Click on the ones that interest you.</h3>
            </div>
            <div class="p-content">
                <div class="p-card">
                    <div class="visible-section" onclick="toggleCard(this.parentElement)">
                        <div class="card-header">
                            <h1>Image Generation using Genetic Algorithm</h1>
                        </div>
                        <div class="card-content">
                            <h3>The project was designed to explore and understand the underlying principles and workings of genetic algorithms in a practical setting.</h3>
                        </div>
                    </div>
                    <div class="card-full-content" style="display: none;">
                        <h3>Introduction</h3>
                        <p>
                            Image generation using a Genetic Algorithm (GA) involves evolving images through iterative processes, mimicking natural selection. 
                            In this approach, an initial population of random images is generated. 
                            These images are then evaluated based on a fitness function, which measures how closely they meet the desired criteria (such as color patterns, shapes, or artistic goals). 
                            The best-performing images are selected for reproduction, where they undergo crossover (mixing parts of images) and mutation (random changes). 
                            This cycle repeats over generations, gradually evolving images that meet the criteria more effectively. 
                            The result is an optimized image generated by the algorithm.
                        </p>
                        <br>
                        <p>A <strong>Genetic Algorithm (GA)</strong> is an optimization technique inspired by the process of natural selection in biology. It solves problems by simulating evolution, where a population of candidate solutions (called <strong>individuals</strong>) evolves over multiple generations to find the best solution.</p>
                        <br>
                        <h3>Key Steps in a Genetic Algorithm:</h3>
                        <ol>
                            <li><strong>Initialization</strong>: Create an initial population of random solutions.</li>
                            <li><strong>Fitness Evaluation</strong>: Each individual solution is evaluated using a <strong>fitness function</strong>, which measures how good the solution is.</li>
                            <li><strong>Selection</strong>: Individuals are selected based on their fitness, with fitter individuals having a higher chance of being selected to reproduce.</li>
                            <li><strong>Crossover (Recombination)</strong>: Selected individuals combine their genetic material (solution components) to create offspring.</li>
                            <li><strong>Mutation</strong>: Small random changes are made to the offspring to introduce diversity.</li>
                            <li><strong>Replacement</strong>: The offspring replace some or all of the old population, forming the new generation.</li>
                            <li><strong>Repeat</strong>: This process is repeated for several generations until an optimal or satisfactory solution is found.</li>
                        </ol>

                        <h3>Advantages:</h3>
                        <ul>
                            <li>GA is highly adaptable and can solve complex optimization problems.</li>
                            <li>It can avoid getting stuck in local optima by maintaining diversity through mutation and selection.</li>
                        </ul>

                        <h3>Image Generation Using Genetic Algorithm</h3>
                        <p>In <strong>image generation</strong> using a Genetic Algorithm (GA), the goal is to evolve images that meet certain desired characteristics. These could be aesthetic properties, patterns, or any other predefined criteria. The GA simulates the process of natural selection and evolution to improve the images over several generations.</p>
                        
                        <h3>Steps Involved in Image Generation Using GA:</h3>
                        <ol>
                            <li><strong>Representation of Images (Chromosomes)</strong>: Each image is represented as a <strong>chromosome</strong>, which is typically an array or matrix of pixel values or image parameters (e.g., color intensities, shapes, or features).</li>
                            <li><strong>Initialization</strong>: The algorithm starts with a population of randomly generated images. These images can be random noise, basic shapes, or pixel patterns, depending on the problem.</li>
                            <li><strong>Fitness Function</strong>: A <strong>fitness function</strong> is used to evaluate how well each image meets the desired criteria. For example, if the goal is to generate an image that matches a target, the fitness function might compare pixel differences or overall color distribution between the generated image and the target.</li>
                            <li><strong>Selection</strong>: Images are selected to be parents for the next generation based on their fitness scores. Fitter images, meaning those closer to the desired output, have a higher chance of being selected.</li>
                            <li><strong>Crossover (Recombination)</strong>: The selected images undergo <strong>crossover</strong>, where parts of two parent images are combined to create offspring. This step helps to pass desirable traits from both parents to their offspring, such as color patterns or shapes.</li>
                            <li><strong>Mutation</strong>: Occasionally, small random changes are made to the offspring's image in a process called <strong>mutation</strong>. This introduces diversity and ensures the algorithm doesn't get stuck in a local optimum.</li>
                            <li><strong>New Generation</strong>: The offspring created through crossover and mutation form the new population. This generation is evaluated using the fitness function, and the process repeats. Over time, the images evolve towards the desired result.</li>
                            <li><strong>Termination</strong>: The process continues for multiple generations until the evolved image satisfies the desired criteria, or until a predefined number of generations are completed.</li>
                        </ol>

                        <h3>How it was done here:</h3>
                        <p>Imagine the goal is to generate an image that closely matches a famous logo:</p>
                        <ul>
                            <li><strong>Initial Population</strong>: The first set of random images is created (random shapes arrangements).</li>
                            <li><strong>Fitness Evaluation</strong>: The fitness function measures how close each image is to the target painting by comparing their pixel values or overall structure.</li>
                            <li><strong>Selection</strong>: The best images, those that are closest to the target, are selected as parents.</li>
                            <li><strong>Crossover</strong>: The selected images are combined to form new offspring (mixing parts of the best images).</li>
                            <li><strong>Mutation</strong>: Small random changes (such as altering a pixel’s color or position) are applied to introduce variety.</li>
                            <li><strong>Repeat</strong>: This process is repeated for many generations, with the images gradually improving until one closely resembles the target painting.</li>
                        </ul>

                        <h3>Implementation and output</h3>
                        <p>
                            As the similarity reaches 70%, it starts showing as blurred image of
                            the target. This is the closest I got in a limited time as the
                            program starts to take more and more time to improve the similarity
                            as the algorithm reaches the convergence slowly
                        </p>
                        <br>
                        <img src="img/pro-img-gen-GA.png" alt="implementation">
                        <br>
                        <h3>Summary:</h3>
                        <p>
                            In conclusion, the implementation of a genetic algorithm for image
                            generation has demonstrated both the potential and challenges in
                            harnessing computational techniques to produce visual content. This
                            shows how a concept of “the survival of the fittest” from biology, a
                            subject way different from computer science manage to improve and
                            provide a new angle to the making of the algorithm.
                            <br>
                            This implementation has underscored the significance of optimizing
                            various parameters within the genetic algorithm framework. The
                            careful adjustment of population size, mutation rates, crossover
                            mechanisms, and fitness evaluation were pivotal in steering the
                            algorithm towards producing images that exhibit desired target
                            characteristics.
                            <br>
                            I manage to utilize this technique to make a simple image generation
                            algorithm, which generates the images that resembles the target and
                            and provides a complete solution.
                        </p>
                        
                        <div class="links">
                            <a href="https://github.com/SpondanB/2105907_AI" target="_blank">
                                <div class="git-link">Repository link</div>
                            </a>
                        </div>
                    </div>
                </div>

                <div class="p-card">
                    <div class="visible-section" onclick="toggleCard(this.parentElement)">
                        <div class="card-header">
                            <h1>Making a game using gesture recognition</h1>
                        </div>
                        <div class="card-content">
                            <h3>Developed a gesture-controlled game using Python, leveraging OpenCV and MediaPipe for hand tracking.</h3>
                        </div>
                    </div>
                    <div class="card-full-content" style="display: none;">
                        <h3>Introduction</h3>
                        <p>
                            I’ve always been fascinated by how gesture recognition can transform the way we interact with games. So, I decided to give the classic Flappy Bird a fresh twist by integrating hand gestures for control. Instead of tapping the screen or pressing keys, players like me can use hand movements to make the bird "flap" and navigate through the pipes. Using tools like MediaPipe and OpenCV, I was able to create a system that tracks gestures such as finger's pinching motion, which trigger the bird’s movement. The result is an immersive, interactive experience where my physical actions directly influence the gameplay. It’s a fun challenge to master, and I can’t wait for others to try it out and experience the game in a whole new way.    
                        </p>
                        <br>
                        <p>OpenCV and MediaPipe are two powerful tools commonly used for computer vision tasks, including hand tracking. I used them to make the needed input system for the game's need.</p>
                        <br>
                        <h3>Working of the two libraries:</h3>
                        <ol>
                            <li><strong>Capture Image/Video:</strong> OpenCV is used to acquire images or video from the camera.</li>
                            <li><strong>Hand Detection:</strong> The image is passed to MediaPipe, which detects the hand in the frame and extracts the 21 keypoints of the hand.</li>
                            <li><strong>Keypoint Visualization:</strong> Using OpenCV, you can visualize the hand keypoints, often by drawing circles or lines over the landmarks on the frame.</li>
                            <li><strong>Tracking:</strong> If the hand moves in subsequent frames, MediaPipe continuously detects and updates the hand's keypoints, and OpenCV can render these in real time.</li>
                        </ol>
                    
                        <p>This combination allows real-time hand tracking in various applications</p>
                        
                        <br>
                        <p>
                            This was used trach a particular gesture, in this case the pinching motion of the finger, to replace the regular input of the player in the Flappy Bird game.
                        </p>
                        <br>
                        <h3>Implementation and output</h3>
                        <img src="img/pro-flappy-ges.png" alt="implementation">
                        <br>
                        <br>
                        <h3>Summary</h3>
                        <p>
                            Integrating hand gestures into games like Flappy Bird enhances the player experience by
                            adding a physical dimension to gameplay, fostering active engagement with the virtual
                            environment. By controlling in-game elements through gestures, players enjoy a more
                            immersive and intuitive control scheme, enhancing their sense of agency within the game
                            world.
                            <br>
                            Looking ahead, the integration of hand gestures into games like Flappy Bird could advance
                            further, potentially incorporating advanced gesture recognition systems for enhanced
                            precision and expanding into VR and AR gaming experiences. This evolution could
                            revolutionize player interactions with virtual worlds, opening up new possibilities for
                            gameplay mechanics and experiences.
                        </p>

                        
                        <div class="links">
                            <a href="https://github.com/SpondanB/FlappyBirdWithGestures" target="_blank">
                                <div class="git-link">Repository link</div>
                            </a>
                        </div>
                    </div>
                </div>
                <div class="p-card">
                    <div class="visible-section" onclick="toggleCard(this.parentElement)">
                        <div class="card-header">
                            <h1>Study of Principle Component Analysis</h1>
                        </div>
                        <div class="card-content">
                            <h3>This project was done to assess the impact of dimensionality reduction and how it's implemented.</h3>
                        </div>
                    </div>
                    <div class="card-full-content" style="display: none;">
                        <p><strong>Principal Component Analysis (PCA)</strong> is a statistical technique used to simplify the complexity of high-dimensional data while retaining trends and patterns. It transforms the data into a set of orthogonal (uncorrelated) variables called "principal components." These components are ordered so that the first few retain most of the variation in the data.</p>

                        <h3>Key Concepts:</h3>
                        <ul>
                            <li><strong>Dimensionality Reduction:</strong> PCA reduces the number of variables (or features) by projecting the original data into a lower-dimensional space.</li>
                            <li><strong>Variance Maximization:</strong> The principal components capture the maximum variance in the data, helping to identify the most important features.</li>
                            <li><strong>Orthogonality:</strong> The new dimensions (principal components) are orthogonal, meaning they are uncorrelated and independent of each other.</li>
                        </ul>
                        <h3>Steps for Implementing PCA:</h3>
                        <ol>
                            <li><strong>Standardize the Data:</strong> PCA works best when the data is centered, so the first step is to standardize the dataset. This involves subtracting the mean of each feature from the dataset and dividing by the standard deviation.</li>
                            <li><strong>Compute the Covariance Matrix:</strong> The covariance matrix represents how the features vary together. It is calculated by taking the dot product of the standardized data with its transpose.</li>
                            <li><strong>Calculate Eigenvalues and Eigenvectors:</strong> The eigenvectors and eigenvalues of the covariance matrix are calculated using linear algebra methods. The eigenvectors represent the directions of maximum variance (principal components), and the eigenvalues represent the amount of variance in each direction.</li>
                            <li><strong>Sort Eigenvectors:</strong> The eigenvectors are sorted in descending order of their corresponding eigenvalues. The top eigenvectors correspond to the most significant principal components.</li>
                            <li><strong>Project the Data:</strong> Finally, the original dataset is projected onto the top k eigenvectors to reduce its dimensionality.</li>
                        </ol>

                        <h3>Summary</h3>
                        <p>PCA is a valuable tool in data analysis and machine learning. It simplifies complex data while retaining the most important patterns, making it easier to model and interpret. Whether for reducing dimensionality, enhancing model performance, or visualizing data, PCA plays a critical role in handling high-dimensional datasets efficiently.</p>
                        <div class="links">
                            <a href="https://github.com/SpondanB/PrincipleComponentAnalysisStudy" target="_blank">
                                <div class="git-link">Repository link</div>
                            </a>
                        </div>
                    </div>
                </div>
                <div class="p-card">
                    <div class="visible-section" onclick="toggleCard(this.parentElement)">
                        <div class="card-header">
                            <h1>A* Path finding using Python</h1>
                        </div>
                        <div class="card-content">
                            <h3>A visualization tool for A* path finding algorithm in Artificial Intelligence.</h3>
                        </div>
                    </div>
                    <div class="card-full-content" style="display: none;">
                        <p>The <strong>A* algorithm</strong> is a popular and efficient pathfinding algorithm used in computer science, especially in fields like artificial intelligence, robotics, and game development. It is commonly used to find the shortest path from a starting point to a goal point while avoiding obstacles in a grid or graph.</p>
                        <br>
                        <h3>How A* Algorithm Works:</h3>
                        <p>The A* algorithm combines the strengths of two other well-known algorithms: Dijkstra's Algorithm (which finds the shortest path) and Greedy Best-First-Search (which chooses paths that are closer to the goal). A* uses both the actual cost from the start node and a heuristic estimate of the cost to the goal to guide its search.</p>
                        <br>
                        <h3>Key Components of A* Algorithm:</h3>
                        <ul>
                            <li><strong>g(n):</strong> The actual cost to reach the current node <em>n</em> from the start node. This is the cost of the path already taken.</li>
                            <li><strong>h(n):</strong> The heuristic estimate of the cost to reach the goal from the current node <em>n</em>. This is an educated guess based on the specific problem and environment (e.g., straight-line distance, Manhattan distance).</li>
                            <li><strong>f(n):</strong> The total estimated cost of the path through node <em>n</em>. It is calculated as the sum of <strong>g(n)</strong> and <strong>h(n)</strong>: <code>f(n) = g(n) + h(n)</code>.</li>
                        </ul>

                        <h3>Steps of the A* Algorithm:</h3>
                        <ol>
                            <li>Start by initializing the open list (nodes to be evaluated) with the starting node and the closed list (nodes already evaluated) as empty.</li>
                            <li>While the open list is not empty, do the following:
                                <ul>
                                    <li>Select the node with the lowest <strong>f(n)</strong> value from the open list.</li>
                                    <li>If this node is the goal node, reconstruct the path from the start node to the goal node and return it.</li>
                                    <li>Otherwise, move the node to the closed list and evaluate its neighbors.</li>
                                    <li>For each neighbor, calculate <strong>g(n)</strong>, <strong>h(n)</strong>, and <strong>f(n)</strong>. If the neighbor is not in the open list or has a better <strong>f(n)</strong> value, add it to the open list.</li>
                                </ul>
                            </li>
                            <li>Repeat this process until the goal node is found or the open list is empty (which means no path exists).</li>
                        </ol>

                        <h3>Advantages of A* Algorithm:</h3>
                        <ul>
                            <li><strong>Optimal Path:</strong> A* is guaranteed to find the optimal path if the heuristic is admissible (i.e., it never overestimates the true cost).</li>
                            <li><strong>Efficiency:</strong> A* balances the exploration of the search space and the focus on the goal, making it more efficient than brute-force search methods.</li>
                            <li><strong>Flexible Heuristic:</strong> The heuristic function can be customized based on the problem, allowing A* to adapt to different types of pathfinding tasks.</li>
                        </ul>
                        <p>Visualizing the A* algorithm helps in understanding how it explores the search space, evaluates paths, and converges towards the goal. It makes the algorithm's decision-making process transparent and demonstrates how it balances between the actual path cost and the estimated cost to the goal.</p>
                        <br>
                        <h3>Key Aspects of A* Visualization:</h3>
                        <ul>
                            <li><strong>Search Space:</strong> The search space here is represented as a grid, with nodes that can either be passable or blocked. The start and goal points are marked, and the algorithm searches for the best path between them.</li>
                            <li><strong>Open and Closed Lists:</strong> The open list (nodes to be evaluated) and the closed list (nodes that have already been evaluated) are visualized through different colors. As A* explores the space, nodes move from the open list to the closed list, showing the algorithm’s progress.</li>
                            <li><strong>Pathfinding Process:</strong> Each node is evaluated based on its <em>f(n)</em> value, which is the sum of the actual cost <em>g(n)</em> and the heuristic estimate <em>h(n)</em>. Nodes with lower <em>f(n)</em> values are prioritized, leading the algorithm to the optimal path. This can be visualized by showing which nodes are chosen first.</li>
                            <li><strong>Path Reconstruction:</strong> Once the goal is reached, the path is reconstructed by tracing back from the goal node to the start node, showing the optimal path found by the algorithm.</li>
                        </ul>
                        <h3>Summary</h3>
                        <p>Visualization of the A* algorithm provides a clear understanding of how it efficiently searches for the optimal path. By showing how it explores the grid, evaluates paths, and reconstructs the solution, visualizations make it easier to grasp the underlying mechanics of the algorithm and how it balances exploration and exploitation of the search space.</p>

                        <div class="links">
                            <a href="https://github.com/SpondanB/A-Star_Path_finding_python" target="_blank">
                                <div class="git-link">Repository link</div>
                            </a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Footer Section -->
    <footer>
        <div class="social-links">
            <a href="https://github.com/SpondanB" target="_blank" alt="GitHub"><img src="https://cdn0.iconfinder.com/data/icons/shift-logotypes/32/Github-1024.png" alt="GitHub"><!--GitHub🐈‍⬛--></a>
            <a href="https://www.linkedin.com/in/spondan-bandyopadhyay-562b15291/" target="_blank" alt="LinkedIn"><img src="https://cdn0.iconfinder.com/data/icons/social-hatched-block-set/512/linkedIn-512.png" alt="LinkedIn"><!--LinkedIn🪪--></a>
            <a href="mailto:spondan2003@gmail.com" alt="Email"><img src="https://cdn0.iconfinder.com/data/icons/iconico-3/128/58.png" alt="Email"><!--Email📧--></a>
        </div>
        <div class="copyright">&copy;  Copyright Spondan 2025</div>
        <div class="copyright">Designed and developed by Spondan Bandyopadhyay</div>
    </footer>

    <script src="js/project-script.js"></script>
</body>
</html>
